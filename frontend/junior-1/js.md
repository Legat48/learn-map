# JavaScript

<details>
<summary>Содержание</summary>

- [Данные](#данные)
- [Выражения](#выражения)
- [Массивы](#массивы)
- [Функции](#функции)
- [Прототипы](#прототипы)

 </details>

## Данные

* Какие типы данных есть в JS?
Есть простые типы данных:
7 приметивных:
1. Число- (±2 в степени 53 -1, 64-битная память) (number),
Cпециальные числовые! значения NaN (не число, вычеслительная ошибка) Infinity (бесконечность) (относятся к number)
2. Большое число(символ "n" в конце означает, что это bigint
)(bigint) для хранения Long, Без верхнего предела
3. Строка(string),
4. Булевый/Логический тип(boolean),
5. null(null)-значение пусто,
6. undefined(значение - не назначено)(undefined).
7. Символ(symbol) -  это отдельный примитивный тип данных, предназначенный для создания уникальных идентификаторов.
символы не включаются в список перечисляемых ключей объекта, полученных методом Object.keys()
И сложный тип данных
8.  object - тип данных использующийся для хранения коллекций значений и иных объектов
array и function - частные случаи объектов

* Какие типы в JS изменяемые, а какие нет?
В JavaScript различают изменяемые (mutable) и неизменяемые (immutable) типы данных.
Приметивные типы данных не изменяемые, а object изменяемый

* Что значит ссылка на переменную?
Переменная хранит не само значение, а ссылку на область памяти, где находится это значение. Для приметивных данных переменные не хранят ссылки, для объектов - хранят ссылку на переменную от которой присваивали себе значение.

* Что такое `NaN`? Как проверить, что переменная - `NaN`?
"не число" или ошибка вычисления. Проверяется isNaN(NaN) - true
* Что значит создавать переменную через конструктор или через литерал? Есть ли отличия?
Через литерал это прямое присваивание объекта в переменную. Через конструктор это присваивание переменной через класс который возвращает объект при создании.
Литеральное - производительнее и проще. Через конструктор стоит создавать только при необходимости создать сложный объект.

* Когда при обращении к свойству объекта стоит использовать точечную нотацию, а когда квадратные скобки?
Точечную нотацию следует использовать когда явно известно ключ свойства объекта.
Обращение через квадратные скобки следует использовать для обращение к нужному свойству объекта ключ которого содержит определенную выше по коду переменную и изначально небыл известен.

* Что произойдет, если попытаться получить несуществующее в объекте свойство?
Вернется undefined

* Что делает `hasOwnProperty`?
Функция которая проверяет содержит ли объект свойство с указанным ключем
* Когда использовать `null`, а когда `undefined`?
null - когда нужно объявить переменную и занять под неё память (что бы переменная существовала) null подчеркивает что переменная пуста.
undefined - для описания того, что переменная без значения или произошла какая то ошибка

* Какие есть способы создания глобальных переменных?
Создание переменной в глобальной области видимости - в документ или виндов
Присваивание к globalObject нового свойства через globalObject.set
Создание тега html с присвоенным id - это тоже переменная
* Для чего нужна директива `use strict`?
необходима для обеспечения строгих правил написания кода и управления состоянием переменных в JavaScript.
  Запрет на неинициализацию переменных:
Все переменные должны быть инициализированы до их использования. Это предотвращает появление неопределённых значений в коде.
  Контроль типов данных:
JavaScript строго контролирует типы данных, что помогает избегать ошибок, связанных с неправильным пониманием типов данных.
  Управление циклом и ветвями:
use strict помогает избежать проблем с управлением циклами и ветвями, обеспечивая более понятный и предсказуемый код.
  Автоматизация очистки памяти:
В режиме строгого контроля памяти JavaScript автоматически очищает неиспользуемые переменные, что уменьшает нагрузку на систему и улучшает производительность.
  Предсказуемость поведения программы:
Благодаря строгому контролю типов данных и состояния переменных, программа становится более предсказуемой и устойчивой к ошибкам.

#### Ресурсы

* [Types (Airbnb JavaScript Style Guide)](https://github.com/airbnb/javascript#types)
* [Объекты как ассоциативные массивы](https://learn.javascript.ru/object)

## Выражения

* Что такое выражения и инструкции? В чем отличия между ними?
Выражение это операция с вычислением или присвоением и всегда возвращает значение.
Инструкция это действие внутри кода и не обязательно, что она что то должна возвращать.
* Чем отличаются `var`, `let`, `const`? Почему использование `const` может быть предпочтительнее?
Отличие const от var и let тем, что значение должно быть присвоено в момент объявления и оно становится неизменяемым. Неизменяемы приметивные типы, но с объектами можно проводить действия.
Вар отличается от лет и конст тем, что оно, вне зависимости от места объявления поднимается на самый верх области видимости и фактически объявляется там, её видно в начале области видимости. В строке где объявлена вар переменная присваивается значение и значение может быть присвоенно такой переменной выше чем объявление. Переменные let и const не видно до места их объявления.
Так же у вар функциональная область видимости, это значит, что её текущее значение видно и выше блочной видимости в которой она объявлена и ограничена верхняя граница видимости текущей функцией в которой вызвана переменная.
Предпочтительнее для ясности кода, производительность лучше и защищает от ошибок

* Что такое тернарный оператор?
Это оператор ? : где перед вопросом булево значение и в зависимости от тру или фолс будет выполнено то что до двоеточия или после двоеточия.

* Что делает оператор `for..in`? Какие имеются особенности при использовании этого оператора с массивами?
это оператор цикла для перебора свойств объекта
При проходе по массиву проходит и по присвоенным ключам через прототип.
Не гарантируется порядок обхода и разный в разных браузерах и версиях

* Как безопасно проверить, что переменная существует (была объявлена), и не словить ReferenceError?
проверить переменную что у неё тип не undefined

#### Ресурсы

* [Выражения и инструкции](https://ru.hexlet.io/courses/introduction_to_programming/lessons/expressions/theory_unit)
* [JavaScript: Выражения и инструкции](https://puzzleweb.ru/javascript/2_syntax3.php)
* [Variable Declarations](https://www.typescriptlang.org/docs/handbook/variable-declarations.html)

## Массивы

* Способы создания массивов (литерал, конструктор, фабричные методы `Array.from()` и `Array.of()`);
Способы:
1. Квадратные ковычки [];
2. new Array()
3. Array.from() - создает массив из итерируемых объектов (можно из 'abc' получить сразу ['a', 'b', 'c']) и более сложное (с применением вторым аргументом функции) и тд
4. `Array.of()` - для создания массива содержащий число ( new Array(3); - [ , , ], а Array.of(3); // Массив с одним элементом: [3])


* Удаление элемента из массива (какие есть способы и в чем особенности);
1. splice() - удаляет элементы из массива начиная от определенного (можно их заменить). Изменяет существующий массив. Вернет удаленные. Индексы исходного массива сдвигаются
2. filter() - цикл который возвращает отфильтрованный новый массив по результату функции в которой возвращается булевый ответ по элементу массива. Исходный не меняет.
3. pop() - удаляет в исходном массиве последний элемент и возвращает удаленное
4. shift() - удаляет в исходном массиве первый элемент и возвращает удаленное



* Свойство `length` у массива
  * Какое значение будет у свойства `length` массива `a` и почему:
      ```javascript
      const a = [1, 2, 3];
      a[10] = 4;
      ```
      Массив расширяется автоматически встроенными свойствами Arrey до индекса 10 и будет длина 11
  * Что будет, если переприсвоить новое значение `length`?
    Если стандартное число - увеличится или уменьшится исходный массив и выкинет не влезшие данные начиная с конца. Другой тип данных попробует привестись к числу и если не получится то будет ошибка
  * Влияет ли на `length` удаление элемента посередине массива? Какие способы удаления элементов влияют на длину, а какие нет?
    Если индексы массива сдвигаются то изменит значение. Если индексы не сдвигаются и не увеличиваются то нет.
* Как проверить, что в переменной лежит массив?
    Array.isArray()
* Что делают, как и когда использовать следующие методы:
  * `reduce` -  это метод свёртки массива, суммирует возвращенные значения функции колбека возвращает это значение
  * `sort` - цикл сортирует массив (стандартно по величине числа или по алфавиту) можно передать условие в функции колбека
  * `filter` - цикл который возвращает отфильтрованный новый массив по результату функции в которой возвращается булевый ответ по элементу массива. Исходный не меняет.
  * `map` - цикл который применяет функцию к каждому значению массива и возвращает новый массив.
  * `forEach` - цикл проходящий по всему массиву до конца, ничего не возвращает
  * `some` - цикл возвращает true или false в зависимости есть ли хотя бы 1 элемент удолетворяющий переданной функции колбека (прекращает проходку по первому совпадению)
  * `every` - цикл возвращает true если все элементы удолетворяют переданной функции колбека (прекращает проходку по первому совпадению), иначе false

#### Ресурсы

* [Массивы. MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array)

## Функции

* Какие есть 4 шаблона вызова функции, которые задают контекст выполнения этой функции?
  * Объявление функции function declaration - объявление именнованной функции function func() {}
  * Экстракция функции function extraction - объявление через присваивание к переменной let func = function() {}
  * стрелочные функции - func = () => {}
  * IIFE ИФЕЕ-шаблон вызова функции (func)()()

* Как директива `use strict` влияет на `this` внутри функции?
  При строгом стиле нет доступа к `this` у стрелочных фукнций.
* Какой наиболее простой паттерн, позволяющий облегчить читаемость функции, когда у нее огромное количество аргументов?
  Передать в виде одного Объекта параметров

* Как получить все аргументы функции (включая те, что не объявлены, но все-таки были переданы)?
  В функции существует псевдомассив `arguments` который содержит всё что в неё передали, что бы получить его как массив нужно использовать Array.from(arguments)

* Что такое рекурсия? Когда удобно её использовать?
Это вызов функции внутри самой функции. Она вызывает сама себя.
Полезно при проходе по любому объекту или массиву в глубину и для создания каких либо значений по таймеру (слежения за чем то) где нужно знать условие

* Что такое замыкания, и в каких случаях они могут быть полезны? Как сохранить состояние с помощью замыкания, и для чего это состояние может быть использовано?
Замыкание — это комбинация функции и лексического окружения(доступные переменные), в котором эта функция была создана.
Функция запомнит все внешние переменные в момент создания и и будет ссылаться на её текущее значение даже если в новом контексте выполнения есть новая переменная с таким названием.
Функция имеет доступ к переменным даже если она выйдет из области видимости наверх.

* Как реализовать функцию `bind`?
  Функция `bind` в JavaScript используется для привязки контекста `this`
  Нужно передать в функция.bind() новый контекст и вернется новая функция с новым контекстом

* Решить такую вот проблему: пускай у нас есть массив ссылок, и наша задача — сделать так, чтобы при клике на каждую выводился `alert`ом ее порядковый номер. Первое решение, что приходит в голову, выглядит так:
  ```javascript
  for (var i = 0; i < links.length; i++) {
     links[i].onclick = function() {
        alert(i);
     }
  }
  ```
  На деле же оказывается, что при клике на любую ссылку выводится одно и то же число — значение `links.length`. Почему так происходит и как эту гадость исправить?

  *Проблема в замыкании на переменной объявленной c с помощью `var`. Функция запомнила ссылку на переменную, которая меняется в цикле и на момент нажатия эта переменая уже записана как links.length - 1. Что бы исправить стоит использовать `let`.

* Что такое callback (функция обратного вызова)? Когда они обычно применяются?
  Callback это функция которая передается в другую функцию или выражение как аргумент

* Что такое каррирование?
Каррирование - это процесс преобразования функции, которая принимает несколько аргументов, в серию вложенных функций, каждая из которых принимает только один аргумент.
  ```javascript
  function curriedAdd(a) {
      return function(b) {
          return a + b;
      };
  }
  const addFive = curriedAdd(5);\z
  console.log(addFive(3)); // 8
  ```

* Что такое частичное применение?

Частичное применение - это техника, позволяющая зафиксировать некоторые аргументы функции и создать новую функцию с меньшим количеством аргументов.
С использованием замыкания
  ```javascript
    const fixedTaxRate = 0.15; // Предположим, ставка налога составляет 15%

    const calculateTaxWithClosure = (income) => calculateTax(income, fixedTaxRate);

    console.log(calculateTaxWithClosure(60000)); // 9000
  ```

* Что такое мемоизация?
  Мемоизация — сохранение результатов выполнения функций для предотвращения повторных вычислений.

#### Ресурсы

* [Some Closure on Closures](https://dev.to/jckuhl/some-closure-on-closures-44ga)
* [What's so useful about closures (in JS)?](https://softwareengineering.stackexchange.com/questions/203507/whats-so-useful-about-closures-in-js)
* [Why would a program use a closure?](https://softwareengineering.stackexchange.com/questions/285941/why-would-a-program-use-a-closure)
* [Четыре паттерна вызова функций в JavaScript](https://habr.com/ru/post/155815/)
* [Каррирование функций в JavaScript](https://habr.com/ru/company/ruvds/blog/427295/)
* [Продвинутая реализация каррирования](https://learn.javascript.ru/currying-partials)
* [Мемоизация в JS и ускорение функций](https://habr.com/ru/company/ruvds/blog/332384/)

## Прототипы

* Что такое функция-конструктор? Как их создавать и как ими пользоваться?
Функция-конструктор - используется для создания объектов. Вызывается с ключевым свойством new. Классы - сахар на функции конструкторы.
* Что такое прототип? Какие возможности имеет/дает?
Прототип это шаблон текущего объекта. Дает возможность присваивать объекту новые свойства и методы. У функций-конструкторов(классов) с помощью присваивания через прототип можно присвоить свойства и методы всем созданным от него объектам.
* Как работает свойство `.prototype`?.
Оно добавляет переданное с ним значение или функцию к объекту по заданному ключу. Если это касается функций-конструкторов - то всем объектам наследникам.
* Почему методы объекта лучше хранить в прототипе, а не в самом объекте?
  В случае с работой от функций-конструкторов, это экономит память, тк функция существует в единственном экземпляре и в определенных случаях это удобно, тк изменить метод достаточно будет в 1 месте.
* Можно ли создать инстанс функции через конструктор? И если да, то как, а если нет, то какой бы интерфейс вы реализовали бы для этой задачи?
  `Инстанс функции` в контексте программирования - это экземпляр класса, созданный на основе функции-конструктора.
  Каждая функция может быть функцией конструктором.
  ```javascript
  function MyFunction() {
    this.message = "Привет!";
  }
  ```
  И на основе неё можно создать объект через new
  Можно без использования функции конструктора. Тогда функция должно возвращать объект.
* Как создать объект, который ни от чего не наследуется?
  С помощью литерала {}
* Какие 3 (как минимум) способа есть отнаследоваться в JavaScript-е? В чем отличия и нюансы?
  1. Использование класса, extends при определении класса (родитель может быть только 1) и new при создании
  2. Использование прототипа и new при создании
  3. Наследование через Object.create() который позволяет передать прототип и без и new при создании
   ```javascript
  const catMethods = {
    speak() {
        console.log(`${this.name} говорит: Мяу!`);
    }
  };

  function createCat(name) {
      const obj = Object.create(catMethods);
      obj.name = name;
      return obj;
  }

  const cat = createCat('Кошка');
  cat.speak(); // Кошка говорит: Мяу!
  ```

* Как в переопределенном методе у наследующего класса вызвать переопределяемый метод родительского?
  Ключевое слово `super`, которое позволяет обратиться к методам и свойствам родительского класса.
  Пример псевдокода:
  ```javascript
  class Person
      method getFullName()
          return this.name + this.surname

  class Employee extends Person
      method getFullName()
          return super() + this.position
  ```
* Какие есть способы навсегда привязать метод класса к его инстансу (чтобы `this` всегда был текущим экземпляром класса)?
При передачи функции в которой используется `this`, она может сослаться к внешнему контексту не того объекта в котором была создана (в случае использовании функции как колбек)
1. Метод `bind` - передать при вызове функции конкретный `this`
  Метод `bind` позволяет создать новую функцию, которая будет вызвана с заранее установленным контекстом this. Это один из самых популярных способов привязки контекста.
2. Стрелочные функции (arrow functions). Стрелочные функции сохраняют лексическое значение this в момент её определения.
3. Использование приватных полей и слабых ссылок НУЖНО ПОДРОБНО РАЗОБРАТЬСЯ
4. Использование декораторов - методы из сторонних библиотек вызываемые через `@` перед методом
#### Ресурсы

* [ES6 классы](http://jsraccoon.ru/es6-classes)
* [Классы в ECMAScript 6](https://frontender.info/es6-classes-final/)
